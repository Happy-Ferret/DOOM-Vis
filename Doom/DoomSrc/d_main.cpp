#include "../stdafx.h"
//-----------------------------------------------------------------------------
//
// $Id:$
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// $Log:$
//
// DESCRIPTION:
//	DOOM main program (D_DoomMain) and game loop (D_DoomLoop),
//	plus functions to determine game mode (shareware, registered),
//	parse command line parameters, configure game parameters (turbo),
//	and call the startup functions.
//
//-----------------------------------------------------------------------------

#define	BGCOLOR		7
#define	FGCOLOR		8

#include "doomdef.h"
#include "doomstat.h"

#include "dstrings.h"
#include "sounds.h"

#include "z_zone.h"
#include "w_wad.h"
#include "s_sound.h"
#include "v_video.h"

#include "f_finale.h"
#include "f_wipe.h"

#include "m_argv.h"
#include "m_misc.h"
#include "m_menu.h"

#include "i_system.h"
#include "i_sound.h"
#include "i_video.h"

#include "g_game.h"

#include "hu_stuff.h"
#include "wi_stuff.h"
#include "st_stuff.h"
#include "am_map.h"

#include "p_setup.h"
#include "r_local.h"

#include "d_main.h"

#include "DoomCallbacks.h"

char*		wadfiles[MAXWADFILES];

qboolean         nomonsters;	// checkparm of -nomonsters
qboolean         respawnparm;	// checkparm of -respawn
qboolean         fastparm;	// checkparm of -fast

extern  qboolean	inhelpscreens;

skill_t		startskill;
int             startepisode;
int		startmap;
qboolean		autostart;

qboolean		advancedemo;




char		wadfile[1024];		// primary wad file
char		mapdir[1024];           // directory of development maps
char		basedefault[1024];      // default file


void D_CheckNetGame(void);
void D_ProcessEvents(void);
void G_BuildTiccmd(ticcmd_t* cmd);
void D_DoAdvanceDemo(void);


//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
event_t         events[MAXEVENTS];
int             eventhead;
int 		eventtail;


//
// D_PostEvent
// Called by the I/O functions when input is detected
//
void D_PostEvent(const event_t* ev)
{
	events[eventhead] = *ev;
	eventhead = (++eventhead)&(MAXEVENTS - 1);
}


//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//
void D_ProcessEvents(void)
{
	event_t*	ev;

	// IF STORE DEMO, DO NOT ACCEPT INPUT
	if ((gamemode == commercial)
		&& (W_CheckNumForName("map01") < 0))
		return;

	for (; eventtail != eventhead; eventtail = (++eventtail)&(MAXEVENTS - 1))
	{
		ev = &events[eventtail];
		if (M_Responder(ev))
			continue;               // menu ate the event
		G_Responder(ev);
	}
}




//
// D_Display
//  draw current display, possibly wiping it from the previous
//

// wipegamestate can be set to -1 to force a wipe on the next draw
gamestate_t     wipegamestate = GS_DEMOSCREEN;
extern  qboolean setsizeneeded;
extern  int             showMessages;
void R_ExecuteSetViewSize(void);
int	wipestart;

FrameType D_Display(void)
{
	static  qboolean		viewactivestate = false;
	static  qboolean		menuactivestate = false;
	static  qboolean		inhelpscreensstate = false;
	static  qboolean		fullscreen = false;
	static  gamestate_t		oldgamestate = static_cast<gamestate_t>(-1);
	static  int			borderdrawcount;
	int				y;
	qboolean			wipe;
	qboolean			redrawsbar;

	if (nodrawers)
		return FrameType::NORMAL;                    // for comparative timing / profiling

	redrawsbar = false;

	// change the view size if needed
	if (setsizeneeded)
	{
		R_ExecuteSetViewSize();
		oldgamestate = static_cast<gamestate_t>(-1);                      // force background redraw
		borderdrawcount = 3;
	}

	// save the current screen if about to wipe
	if (gamestate != wipegamestate)
	{
		wipe = true;
		wipe_StartScreen();
	}
	else
		wipe = false;

	if (gamestate == GS_LEVEL && gametic)
		HU_Erase();

	// do buffered drawing
	switch (gamestate)
	{
	case GS_LEVEL:
		if (!gametic)
			break;
		if (automapactive)
			AM_Drawer();
		if (wipe || (viewheight != 200 && fullscreen))
			redrawsbar = true;
		if (inhelpscreensstate && !inhelpscreens)
			redrawsbar = true;              // just put away the help screen
		ST_Drawer(viewheight == 200, redrawsbar);
		fullscreen = viewheight == 200;
		break;

	case GS_INTERMISSION:
		WI_Drawer();
		break;

	case GS_FINALE:
		F_Drawer();
		break;

	case GS_DEMOSCREEN:
		D_PageDrawer();
		break;
	}

	// draw the view directly
	if (gamestate == GS_LEVEL && !automapactive && gametic)
		R_RenderPlayerView(&players[displayplayer]);

	if (gamestate == GS_LEVEL && gametic)
		HU_Drawer();

	// clean up border stuff
	if (gamestate != oldgamestate && gamestate != GS_LEVEL)
		I_SetPalette(reinterpret_cast<byte*>(W_CacheLumpName("PLAYPAL", PU_CACHE)));

	// see if the border needs to be initially drawn
	if (gamestate == GS_LEVEL && oldgamestate != GS_LEVEL)
	{
		viewactivestate = false;        // view was not active
		R_FillBackScreen();    // draw the pattern into the back screen
	}

	// see if the border needs to be updated to the screen
	if (gamestate == GS_LEVEL && !automapactive && scaledviewwidth != 320)
	{
		if (menuactive || menuactivestate || !viewactivestate)
			borderdrawcount = 3;
		if (borderdrawcount)
		{
			R_DrawViewBorder();    // erase old menu stuff
			borderdrawcount--;
		}

	}

	menuactivestate = menuactive;
	viewactivestate = viewactive;
	inhelpscreensstate = inhelpscreens;
	oldgamestate = wipegamestate = gamestate;

	// draw pause pic
	if (paused)
	{
		if (automapactive)
			y = 4;
		else
			y = viewwindowy + 4;
		V_DrawPatchDirect(viewwindowx + (scaledviewwidth - 68) / 2,
			y, 0, reinterpret_cast<patch_t*>(W_CacheLumpName("M_PAUSE", PU_CACHE)));
	}


	// menus go directly to the screen
	M_Drawer();          // menu is drawn even on top of everything
	NetUpdate();         // send out any new accumulation


	// normal update
	if (!wipe)
	{
		return FrameType::NORMAL;
	}

	// wipe update
	wipe_EndScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);

	wipestart = I_GetTime() - 1;
	int elapsedTicks;
	return D_DoomWipeFrame(elapsedTicks);
}

FrameType D_DoomWipeFrame(int& elapsedTicks)
{
	int				nowtime;
	int				tics;
	qboolean			done;

	do
	{
		nowtime = I_GetTime();
		tics = nowtime - wipestart;
		if (!tics)
		{
			doomCallbacks->Sleep();
		}
	} while (!tics);
	wipestart = nowtime;

	elapsedTicks = tics;
	done = wipe_ScreenWipe(wipe_Melt, SCREENWIDTH, SCREENHEIGHT, tics);

	M_Drawer();                            // menu is drawn even on top of wipes

	return done ? FrameType::NORMAL : FrameType::WIPE;
}

FrameType D_DoomFrame(int& elapsedTicks)
{
	// process one or more tics
	TryRunTics(elapsedTicks); // will run at least one tic

	S_UpdateSounds(players[consoleplayer].mo);// move positional sounds

	// Update display, next frame, with current state.
	return D_Display();
}

//
//  DEMO LOOP
//
int             demosequence;
int             pagetic;
char                    *pagename;


//
// D_PageTicker
// Handles timing for warped projection
//
void D_PageTicker(void)
{
	if (--pagetic < 0)
		D_AdvanceDemo();
}



//
// D_PageDrawer
//
void D_PageDrawer(void)
{
	V_DrawPatch(0, 0, 0, reinterpret_cast<patch_t*>(W_CacheLumpName(pagename, PU_CACHE)));
}


//
// D_AdvanceDemo
// Called after each demo or intro demosequence finishes
//
void D_AdvanceDemo(void)
{
	advancedemo = true;
}


//
// This cycles through the demo sequences.
// FIXME - version dependend demo numbers?
//
void D_DoAdvanceDemo(void)
{
	players[consoleplayer].playerstate = PST_LIVE;  // not reborn
	advancedemo = false;
	usergame = false;               // no save / end game here
	paused = false;
	gameaction = ga_nothing;

	if (gamemode == retail)
		demosequence = (demosequence + 1) % 7;
	else
		demosequence = (demosequence + 1) % 6;

	switch (demosequence)
	{
	case 0:
		if (gamemode == commercial)
			pagetic = 35 * 11;
		else
			pagetic = 170;
		gamestate = GS_DEMOSCREEN;
		pagename = "TITLEPIC";
		if (gamemode == commercial)
			S_StartMusic(mus_dm2ttl);
		else
			S_StartMusic(mus_intro);
		break;
	case 1:
		G_DeferedPlayDemo("demo1");
		break;
	case 2:
		pagetic = 200;
		gamestate = GS_DEMOSCREEN;
		pagename = "CREDIT";
		break;
	case 3:
		G_DeferedPlayDemo("demo2");
		break;
	case 4:
		gamestate = GS_DEMOSCREEN;
		if (gamemode == commercial)
		{
			pagetic = 35 * 11;
			pagename = "TITLEPIC";
			S_StartMusic(mus_dm2ttl);
		}
		else
		{
			pagetic = 200;

			if (gamemode == retail)
				pagename = "CREDIT";
			else
				pagename = "HELP2";
		}
		break;
	case 5:
		G_DeferedPlayDemo("demo3");
		break;
		// THE DEFINITIVE DOOM Special Edition demo
	case 6:
		G_DeferedPlayDemo("demo4");
		break;
	}
}



//
// D_StartTitle
//
void D_StartTitle(void)
{
	gameaction = ga_nothing;
	demosequence = -1;
	D_AdvanceDemo();
}




//      print title for every printed line
char            title[128];



//
// D_AddFile
//
void D_AddFile(char *file)
{
	int     numwadfiles;
	char    *newfile;

	for (numwadfiles = 0; wadfiles[numwadfiles]; numwadfiles++)
		;

	const size_t len = strlen(file) + 1;
	newfile = reinterpret_cast<char*>(malloc(len));
	strcpy_s(newfile, len, file);

	wadfiles[numwadfiles] = newfile;
}

//
// IdentifyVersion
// Checks availability of IWAD files by name,
// to determine whether registered/commercial features
// should be executed (notably loading PWAD's).
//
void IdentifyVersion(void)
{
	char*	doom1wad;
	char*	doomwad;
	char*	doomuwad;
	char*	doom2wad;
	char*	plutoniawad;
	char*	tntwad;

	const char *doomwaddir = "Data";

	// Commercial.
	size_t bufSize = strlen(doomwaddir) + 1 + 9 + 1;
	doom2wad = reinterpret_cast<char*>(malloc(bufSize));
	sprintf_s(doom2wad, bufSize, "%s/doom2.wad", doomwaddir);

	// Retail.
	bufSize = strlen(doomwaddir) + 1 + 9 + 1;
	doomuwad = reinterpret_cast<char*>(malloc(bufSize));
	sprintf_s(doomuwad, bufSize, "%s/doomu.wad", doomwaddir);

	// Registered.
	bufSize = strlen(doomwaddir) + 1 + 8 + 1;
	doomwad = reinterpret_cast<char*>(malloc(bufSize));
	sprintf_s(doomwad, bufSize, "%s/doom.wad", doomwaddir);

	// Shareware.
	bufSize = strlen(doomwaddir) + 1 + 9 + 1;
	doom1wad = reinterpret_cast<char*>(malloc(bufSize));
	sprintf_s(doom1wad, bufSize, "%s/doom1.wad", doomwaddir);

	// Bug, dear Shawn.
	// Insufficient malloc, caused spurious realloc errors.
	bufSize = strlen(doomwaddir) + 1 + 12 + 1;
	plutoniawad = reinterpret_cast<char*>(malloc(bufSize));
	sprintf_s(plutoniawad, bufSize, "%s/plutonia.wad", doomwaddir);

	bufSize = strlen(doomwaddir) + 1 + 9 + 1;
	tntwad = reinterpret_cast<char*>(malloc(bufSize));
	sprintf_s(tntwad, bufSize, "%s/tnt.wad", doomwaddir);

	//_dupenv_s(&home, nullptr, "HOME");
	//if (!home)
	//	I_Error("Please set $HOME to your home directory");
	sprintf_s(basedefault, "Data/default.cfg");
	//#endif

	if (!_access(doom2wad, R_OK))
	{
		gamemode = commercial;
		D_AddFile(doom2wad);
		return;
	}

	if (!_access(plutoniawad, R_OK))
	{
		gamemode = commercial;
		D_AddFile(plutoniawad);
		return;
	}

	if (!_access(tntwad, R_OK))
	{
		gamemode = commercial;
		D_AddFile(tntwad);
		return;
	}

	if (!_access(doomuwad, R_OK))
	{
		gamemode = retail;
		D_AddFile(doomuwad);
		return;
	}

	if (!_access(doomwad, R_OK))
	{
		gamemode = registered;
		D_AddFile(doomwad);
		return;
	}

	if (!_access(doom1wad, R_OK))
	{
		gamemode = shareware;
		D_AddFile(doom1wad);
		return;
	}

	doomCallbacks->Printf("Game mode indeterminate.\n");
	gamemode = indetermined;

	// We don't abort. Let's see what the PWAD contains.
	//exit(1);
	//I_Error ("Game mode indeterminate\n");
}

//
// D_DoomMain
//
void D_DoomMain(void)
{
	IdentifyVersion();
	modifiedgame = false;

	nomonsters = M_CheckParm("-nomonsters") != 0;
	respawnparm = M_CheckParm("-respawn") != 0;
	fastparm = M_CheckParm("-fast") != 0;

	switch (gamemode)
	{
	case retail:
		sprintf_s(title,
			"                         "
			"The Ultimate DOOM Startup v%i.%i"
			"                           ",
			VERSION / 100, VERSION % 100);
		break;
	case shareware:
		sprintf_s(title,
			"                            "
			"DOOM Shareware Startup v%i.%i"
			"                           ",
			VERSION / 100, VERSION % 100);
		break;
	case registered:
		sprintf_s(title,
			"                            "
			"DOOM Registered Startup v%i.%i"
			"                           ",
			VERSION / 100, VERSION % 100);
		break;
	case commercial:
		sprintf_s(title,
			"                         "
			"DOOM 2: Hell on Earth v%i.%i"
			"                           ",
			VERSION / 100, VERSION % 100);
		break;
		/*FIXME
			   case pack_plut:
			   sprintf (title,
			   "                   "
			   "DOOM 2: Plutonia Experiment v%i.%i"
			   "                           ",
			   VERSION/100,VERSION%100);
			   break;
			   case pack_tnt:
			   sprintf (title,
			   "                     "
			   "DOOM 2: TNT - Evilution v%i.%i"
			   "                           ",
			   VERSION/100,VERSION%100);
			   break;
			   */
	default:
		sprintf_s(title,
			"                     "
			"Public DOOM - v%i.%i"
			"                           ",
			VERSION / 100, VERSION % 100);
		break;
	}

	doomCallbacks->Printf("%s\n", title);

	// get skill / episode / map from parms
	startskill = sk_medium;
	startepisode = 1;
	startmap = 1;
	autostart = false;

	// init subsystems
	doomCallbacks->Printf("V_Init: allocate screens.\n");
	V_Init();

	doomCallbacks->Printf("M_LoadDefaults: Load system defaults.\n");
	M_LoadDefaults();              // load before initing other systems

	doomCallbacks->Printf("Z_Init: Init zone memory allocation daemon. \n");
	Z_Init();

	doomCallbacks->Printf("W_Init: Init WADfiles.\n");
	W_InitMultipleFiles(wadfiles);


	// Check for -file in shareware
	if (modifiedgame)
	{
		// These are the lumps that will be checked in IWAD,
		// if any one is not present, execution will be aborted.
		char name[23][16] =
		{
			"e2m1", "e2m2", "e2m3", "e2m4", "e2m5", "e2m6", "e2m7", "e2m8", "e2m9",
			"e3m1", "e3m3", "e3m3", "e3m4", "e3m5", "e3m6", "e3m7", "e3m8", "e3m9",
			"dphoof", "bfgga0", "heada1", "cybra1", "spida1d1"
		};
		int i;

		if (gamemode == shareware)
			I_Error("\nYou cannot -file with the shareware "
			"version. Register!");

		// Check for fake IWAD with right name,
		// but w/o all the lumps of the registered version. 
		if (gamemode == registered)
		for (i = 0; i < 23; i++)
		if (W_CheckNumForName(name[i]) < 0)
			I_Error("\nThis is not the registered version.");
	}

	// Iff additonal PWAD files are used, print modified banner
	if (modifiedgame)
	{
		doomCallbacks->Printf(
			"===========================================================================\n"
			"ATTENTION:  This version of DOOM has been modified.  If you would like to\n"
			"get a copy of the original game, call 1-800-IDGAMES or see the readme file.\n"
			"        You will not receive technical support for modified games.\n"
			"                      press enter to continue\n"
			"===========================================================================\n"
			);
		getchar();
	}


	// Check and print which version is executed.
	switch (gamemode)
	{
	case shareware:
	case indetermined:
		doomCallbacks->Printf(
			"===========================================================================\n"
			"                                Shareware!\n"
			"===========================================================================\n"
			);
		break;
	case registered:
	case retail:
	case commercial:
		doomCallbacks->Printf(
			"===========================================================================\n"
			"                 Commercial product - do not distribute!\n"
			"         Please report software piracy to the SPA: 1-800-388-PIR8\n"
			"===========================================================================\n"
			);
		break;

	default:
		// Ouch.
		break;
	}

	doomCallbacks->Printf("M_Init: Init miscellaneous info.\n");
	M_Init();

	doomCallbacks->Printf("R_Init: Init DOOM refresh daemon - ");
	R_Init();

	doomCallbacks->Printf("\nP_Init: Init Playloop state.\n");
	P_Init();

	doomCallbacks->Printf("D_CheckNetGame: Checking network game status.\n");
	D_CheckNetGame();

	doomCallbacks->Printf("S_Init: Setting up sound.\n");
	S_Init(snd_SfxVolume * 8, snd_MusicVolume * 8);

	doomCallbacks->Printf("HU_Init: Setting up heads up display.\n");
	HU_Init();

	doomCallbacks->Printf("ST_Init: Init status bar.\n");
	ST_Init();

	if (gameaction != ga_loadgame)
	{
		if (autostart || netgame)
			G_InitNew(startskill, startepisode, startmap);
		else
			D_StartTitle();                // start up intro loop

	}
}
